<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Reduce Function Testing</title>
</head>
<body>
  <script src="../tinytest.js"></script>
  <script>
    // Prototype
    // function reduce(array, callback, startingValue){
    //   let resultSoFar = startingValue;
    //   for (let i = 0; i < array.length; i++){
    //     resultSoFar = callback(resultSoFar, array[i], i, array)
    //   }
    //   return resultSoFar
    // }
    /*
    Syntax or Function Signature:
    arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])

    The reduce() method executes a reducer function (that you provide) on each element of the array, resulting in a single output value.
    The reducer function takes four arguments:
      - Accumulator (acc)
      - Current Value (cur)
      - Current Index (idx)
      - Source Array (src)
    Your reducer function's returned value is assigned to the accumulator, whose value is remembered across each iteration throughout the array and ultimately becomes the final, single resulting value.

    Turn the docs into requirements:
    - reduce(array, callback[, startingValue]) --> startingValue is optional
    - callback parameters: previousValue, currentValue, currentIndex, array
    - returns a single value

    Description:

    The reduce() method executes the callback once for each assigned value present in the array, taking four arguments:
      - accumulator
      - currentValue
      - currentIndex
      - array

    Requirements:
    (normally this would be erased, I leave it here for educational purposes)
    - If initialValue, previousValue should start with initialValue.
    - If initialValue, currentValue should start with array[0].
    - If initialValue, callback will start at index 0.

    - If no initialValue, previousValue should start with array[0].
    - If no initialValue, currentValue should start with array[1].
    - If no initialValue, callback will start at index 1.

    - If initialValue and array is empty, return initialValue without calling callback.
      -  reduce([], function(){}, 0)>>> return 0 without callback;
      -  reduce ([--hole here--, --hole here--], function(){}, 0) >>> return 0 without callback
    - If no initialValue and array has one element, it should return only that element without calling callback.
      -  reduce ([--hole here--, 1], function(){}) >>> return 1 without callback
      -  reduce ([1], function(){}) >>> return 1 without callback
   
    - It should actually reduce.
    - It should exclude holes.

    - Callback should not run on holes in the array
      - (e.g. array[--hole here--, 2,3 ]);
    - If array is empty and not initialValue, throw TypeError.
      - reduce([], function(){}) >>> TypeError
    - It should pass array as fouth argument of callback.      
    */
    
    function reduce (array, callback, initialValue){
      let startingIndex = 0;
      // Detect if there is initialValue
      if(arguments.length < 3) {
        startingIndex++;
      }

      for(let i = startingIndex; i < array.length; i++){
        callback(initialValue, array[0], i);
      }
    };
    tests({
      'If initialValue, callback should run array.length times':function(){
        let numberOfTimesCallbackHasRun = 0;
        reduce([1], function(){
          numberOfTimesCallbackHasRun++;
        }, 0)
        eq(numberOfTimesCallbackHasRun, 1)
      },
      'If no initialValue, callback should run array.length - 1 times':function(){
        let numberOfTimesCallbackHasRun = 0;
        reduce([1], function(){
          numberOfTimesCallbackHasRun++;
        })
        eq(numberOfTimesCallbackHasRun, 0)
      },

      'If initialValue, previousValue should start with initialValue.': function(){
        reduce([1], function(previousValue){
          eq(previousValue, 0)
        },0);
      },
      'If initialValue, currentValue should start with array[0].': function(){
        reduce([1], function(previousValue, currentValue){
          eq(currentValue, 1)
        },0);
      },
      'If initialValue, callback will start at index 0': function(){
        reduce([1], function(previousValue, currentValue, index){
          eq(index, 0)
        },0);
      },

      'If no initialValue, previousValue should start with array[0]': function(){
        fail()
      },
      'If no initialValue, currentValue should start with array[1]': function(){
        fail()
      },
      'If no initialValue, callback will start at index 1': function(){
        fail()
      },

      'If initialValue and array is empty, return initialValue without calling callback': function(){
        fail()
      },
      'If no initialValue and array has one element, it should return only that element without calling callback': function(){
        fail()
      },

      'It should actually reduce': function(){
        fail()
      },
      'It should exclude holes': function(){
        fail()
      },
      'If array is empty and not initialValue, throw TypeError': function(){
        fail()
      },
      ' It should pass array as fourth argument of callback': function(){
        fail()
      }
    })
  </script>
</body>
</html>